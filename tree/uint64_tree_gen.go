package tree

import (
	"errors"
	"fmt"
	"io"
	"math"
)

// Code generated by gen.sh; DO NOT EDIT.

var _ = math.MaxFloat32

var (
	Uint64DefDesc = uint64(math.MaxUint64-1)
	Uint64DefAsc  = uint64(math.MaxUint64-2)
)

//Function called for each event during a TreeWalk.
//Return StopDescent if you don't want to walk down a node further.
type Uint64WalkFunc func(n *Uint64Node, evt Event) (err error)

type Uint64Node struct {
	//don't keep a reference to the parent.
	Value    uint64
	Children []*Uint64Node
}

//A Uint64Codec is used to encode or decode a Uint64Node into/from a slice.
//Slices are easier to store and manage, especially in some app environments e.g. Google App Engine.
type Uint64Codec struct {
	Desc uint64
	Asc  uint64
}

func NewUint64Codec() Uint64Codec {
	return Uint64Codec{Desc: Uint64DefDesc, Asc: Uint64DefAsc}
}

//Decodes the children of Uint64Node n from the slice.
//Note that the "root" ie n is not reflected in the slice.
func (c Uint64Codec) DecodeChildren(n *Uint64Node, vals []uint64) {
	stack := make([]*Uint64Node, 0, 4)
	stack = append(stack, n)
	justDesc := false
	nx := n
	for i := 0; i < len(vals); i++ {
		switch vals[i] {
		case c.Desc:
			justDesc = true
		case c.Asc:
			if justDesc {
				justDesc = false
			} else {
				stack = stack[:len(stack)-1]
			}
		default:
			if justDesc {
				stack = append(stack, nx)
				justDesc = false
			}
			nx = &Uint64Node{Value: vals[i]}
			ny := stack[len(stack)-1]
			ny.Children = append(ny.Children, nx)
		}
	}
}

//Encodes the children of Uint64Node n into the slice .
//Note that the "root" ie n is not reflected in the slice.
//It's okay to pass a nil slice for starters.
func (c Uint64Codec) EncodeChildren(n *Uint64Node, vals []uint64) []uint64 {
	for _, n2 := range n.Children {
		vals = append(vals, n2.Value)
		if len(n2.Children) > 0 {
			vals = append(vals, c.Desc)
			vals = c.EncodeChildren(n2, vals)
			vals = append(vals, c.Asc)
		}
	}
	return vals
}

//Copy returns a deep copy of Uint64Node n.
//This just means that a copy of the node and copies of the children are returned.
//However, the "Value" in each node stays the same.
func (n *Uint64Node) Copy() (n2 *Uint64Node) {
	n2 = &Uint64Node{Value: n.Value}
	if len(n.Children) == 0 {
		return
	}
	n2.Children = make([]*Uint64Node, len(n.Children))
	for i, nx := range n.Children {
		if nx != nil {
			n2.Children[i] = nx.Copy()
		}
	}
	return
}

func (n0 *Uint64Node) fnc(evt0 Event, fn Uint64WalkFunc, xerr *error) (shouldIReturn bool) {
	var err error
	if err = fn(n0, evt0); err != nil {
		if err == StopDescent {
			err = nil
		}
		shouldIReturn = true
	}
	*xerr = err
	return
}

func (n *Uint64Node) dowalk(depthFirst bool, reverse bool, fn Uint64WalkFunc) (err error) {
	xerr := &err
	if n.fnc(EnterEvent, fn, xerr) {
		return
	}
	if !depthFirst {
		if n.fnc(VisitEvent, fn, xerr) {
			return
		}
	}
	if len(n.Children) > 0 {
		for i, nx := range n.Children {
			if reverse {
				nx = n.Children[len(n.Children)-1-i]
			}
			if err = nx.dowalk(depthFirst, reverse, fn); err != nil {
				return
			}
			if n.fnc(BackUpEvent, fn, xerr) {
				return
			}
		}
	}
	if depthFirst {
		if n.fnc(VisitEvent, fn, xerr) {
			return
		}
	}
	return
}

//Walk Uint64Node n, depth first or breadth first, and call fn
//for every event during the Walk.
func (n *Uint64Node) Walk(depthFirst bool, reverse bool, fn Uint64WalkFunc) (err error) {
	err = n.dowalk(depthFirst, reverse, fn)
	return
}

//Write a Uint64Node into a Writer, using the indent string given to signify indents.
func (n *Uint64Node) Write(depthFirst bool, reverse bool, w io.Writer, indentStr string) error {
	stack := make([]*Uint64Node, 0, 4)
	indent := 0
	fn := func(n *Uint64Node, evt Event) (err error) {
		switch evt {
		case EnterEvent:
			stack = append(stack, n)
			indent++
		case VisitEvent:
			for i := 0; i < indent; i++ {
				io.WriteString(w, indentStr)
			}
			io.WriteString(w, fmt.Sprintf("%v\n", n.Value))
			//fallthrough
		case BackUpEvent:
			stack = stack[:len(stack)-1]
			indent--
		default:
			err = errors.New(fmt.Sprintf("Unknown event: %v", evt))
		}
		return
	}
	_ = stack
	return n.Walk(depthFirst, reverse, fn)
}
